[인덱스](#인덱스)

[인덱스 종류](#인덱스-종류)

[인덱스 사용 예시](#인덱스-사용-예시)

[다중 컬럼 인덱스](#다중-컬럼-인덱스-multi-column-index)

[클러스터링 인덱스](#클러스터링-인덱스)
- [보조 인덱스와 클러스터링 인덱스를 통한 탐색 과정](#보조-인덱스와-클러스터링-인덱스를-통한-탐색-과정)
- [클러스터링 인덱스 장단점](#클러스터링-인덱스-장단점)
- [클러스터링 테이블 주의사항](#클러스터링-테이블-주의사항)

[유니크 인덱스](#유니크-인덱스)

[외래 키](#외래-키)

[인덱스 알고리즘](#인덱스-알고리즘)
- [B-Tree Index (Balanced-Tree Index)](#b-tree-index-balanced-tree-index)

[B-Tree 성능에 영향을 미치는 요소](#b-tree-성능에-영향을-미치는-요소)
- [인덱스 키 값의 크기](#인덱스-키-값의-크기)
- [선택도 (기수성)](#선택도-기수성)
- [레코드 건수](#레코드-건수)
- [최적화 팁](#최적화-팁)

[B-Tree 인덱스 스캔](#b-tree-인덱스-스캔)
- [레인지 스캔 (Range Scan)](#레인지-스캔-range-scan)
- [커버링 스캔 (Index-Only Scan)](#커버링-스캔-index-only-scan)
- [풀 스캔 (Full Index Scan)](#풀-스캔-full-index-scan)
- [유니크 인덱스 조회 (Unique Index Lookup)](#유니크-인덱스-조회-unique-index-lookup)
- [루스 인덱스 조회 (Loose Index Scan)](#루스-인덱스-스캔-loose-index-scan)
- [인덱스 스킵 스캔 (Index Skip Scan)](#인덱스-스킵-스캔-index-skip-scan)

[B-Tree 인덱스 정렬 및 스캔 방향](#b-tree-인덱스-정렬-및-스캔-방향)
- [정렬 방향 설정과 쿼리에 따른 스캔 방향 선택](#정렬-방향-설정과-쿼리에-따른-스캔-방향-선택)
- [인덱스 정렬 순서와 ORDER BY에 따른 스캔 방향](#인덱스-정렬-순서와-order-by에-따른-스캔-방향)
- [스캔 방향과 쿼리 성능의 관계](#스캔-방향과-쿼리-성능의-관계)

[쿼리별 인덱스 사용 방법](#쿼리별-인덱스-사용-방법)

## 인덱스

데이터베이스 테이블에서 특정 컬럼 또는 특정 컬럼의 조합에 대한 빠른 조회 성능을 제공하는 데이터 구조를 인덱스라고 함

키-값 쌍의 구조를 가지는데, 키는 인덱싱된 컬럼의 값이고 값은 해당 레코드의 위치를 나타냄

인덱스는 검색, 정렬, 조인 등의 정렬을 빠르게 수행할 수 있도록 도와줌

인덱스가 없는 경우, MySQL은 테이블의 모든 레코드를 순차적으로 검색해야 하므로 성능이 저하될 수 있음

### 색인

인덱스는 책의 색인처럼 작동하는데, 색인에 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소가 됨

DBMS도 데이터베이스의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리므로, 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 인덱스를 만들어두는 것임

### 정렬 상태

인덱스는 저장하는 순서대로 저장되지 않고, **항상 정렬된 상태를 유지**함

쓰기 작업(INSERT, UPDATE, DELETE)의 경우 인덱스의 값이 항상 정렬되어야 하므로 처리가 느려지지만 검색(SELECT) 속도가 향상됨

## 인덱스 종류

**기본 인덱스 (Primary Index)**

기본 키에 대한 인덱스임

테이블 당 하나만 존재하며, 기본 키는 고유성과 NULL 값을 허용하지 않음

**보조 인덱스 (Secondary Index)**

기본 키가 아닌 다른 컬럼에 대한 인덱스임

테이블 당 여러 개의 보조 인덱스를 가질 수 있음

다만 인덱스는 항상 정렬된 상태를 유지해야 되므로, 많은 보조 인덱스는 쓰기 작업의 속도 저하를 불러일으킬 수 있음

**유니크 인덱스 (Unique Index)**

기본 인덱스와 유사하게 인덱스 컬럼의 값이 중복되지 않도록 보장함 (고유성)

다만 NULL 값을 허용함

대체 키라고도 함

**전체 텍스트 인덱스 (Full-Text Index)**

텍스트 검색을 최적화하기 위해 사용됨

일반적으로 텍스트 데이터에서 특정 단어를 빠르게 검색할 때 유용함

## 인덱스 사용 예시

**기본 키만 지정하고, 별도의 인덱스를 만들지 않은 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id)
);
```

기본 키 인덱스만 생성됨(InnoDB는 기본 키를 클러스터형 인덱스로 사용)

**기본 키를 지정하지 않은 경우**

InnoDB 내부적으로 유니크한 클러스터형 인덱스를 생성함

**기본 키에 더해 유니크 인덱스나 세컨더리 인덱스를 추가한 경우**

```mysql
CREATE TABLE example
(
    id   INT AUTO_INCREMENT,
    name VARCHAR(255),
    age  INT,
    PRIMARY KEY (id),              # 기본 인덱스(클러스터형 인덱스)
    UNIQUE KEY unique_name (name), # name 컬럼에 대한 유니크 인덱스
    INDEX idx_age (age)            # age 컬럼에 대한 세컨더리 인덱스
);
```

각 인덱스 종류 별로 인덱스 구조가 생성되서, 검색 작업 및 쓰기 작업 시 쿼리에 따라 특정 인덱스를 사용함

## 다중 컬럼 인덱스 (Multi-Column Index)

2개 이상의 컬럼을 포함하는 인덱스임

각 인덱스 엔트리는 첫 번째 인덱스의 값에 의해 정렬됨

만약 첫 번째 인덱스의 값이 동일한 경우 그 다음 인덱스의 값으로 정렬을 시도하고, 

이 값도 동일하다면 그 다음 인덱스의 값으로 정렬을 시도하는 방식으로 인덱스 엔트리를 정렬함

그래서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요함


## 클러스터링 인덱스

클러스터링 인덱스
- 클러스터링이란 비슷한 데이터를 물리적으로 가까운 위치에 저장하여 검색을 향상시키는 기법임
- 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 사용되는 인덱스로, **기본 키**를 기준으로 값이 비슷한 것들끼리 묶어서 테이블 레코드에 빠르게 접근할 수 있도록 함
- 테이블의 레코드 저장 위치가 클러스터링 인덱스인 기본 키에 의해 결정되므로 "클러스터링 테이블"이라고도 함

기본 키
- 기본 키가 테이블의 클러스터링 인덱스를 구성함 (그래서 기본 키를 "클러스터링 키"라고도 함)
- 인덱스의 리프 노드에서 실제 테이블의 행 데이터 자체를 포함 (기본 키-특정 페이지의 레코드 데이터가 매핑된 구조)
- 따라서 기본 키 값이 변경되면 매핑된 레코드의 물리적인 저장 위치가 바뀌어야 함 (MyISAM이나 MEMORY 테이블의 경우 한 번 저장된 레코드는 절대 이동하지 않는 것과 대비됨)

보조 인덱스
- 기본 키가 아닌 다른 컬럼을 인덱스를 구성함
- 이 인덱스의 리프 노드는 기본 키 값을 가르킴
- 보조 인덱스는 클러스터링 인덱스라고 표현하지 않음

기본 키가 없는 경우엔 다음의 우선순위대로 기본 키를 대체할 컬럼을 선택함
- NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
- 자동으로 유니크한 값을 가지도록 증가되는 컬럼("ROW ID")을 내부적으로 추가한 후, 클러스터링 키로 선택
- 즉, InnoDB 스토리지 엔진에선 기본 키가 없어도 기본적으로 클러스터링 인덱스를 구성함

### 보조 인덱스와 클러스터링 인덱스를 통한 탐색 과정

```mysql
# 예시 테이블 
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50)
);

# 보조 인덱스 (first_name 컬럼)
CREATE INDEX idx_first_name ON employees (first_name);

# 쿼리
SELECT * FROM employees WHERE first_name = "Smith";
```

idx_first_name 인덱스를 통해 레코드의 기본 키 값을 찾고(B-Tree), 기본 키 값으로 검색하는 과정(B-Tree)을 한 번 더 거쳐서 진짜 레코드를 찾아옴

### 클러스터링 인덱스 장단점

**장점**
- 빠른 검색
  - 기본 키를 기준으로 정렬된 상태를 유지하며 레코드를 저장하므로, 기본 키를 사용한 검색(범위 검색 등)이 매우 빠름
  - 연속적인 레코드를 읽을 때 디스크 I/O를 최소화할 수 있음
- 리프 노드에 레코드 저장
  - 클러스터링 인덱스의 리프 노드에 인덱스와 실제 레코드 데이터를 함께 저장함
  - 추가적인 데이터 검색 없이 인덱스 탐색만으로도 원하는 데이터를 검색할 수 있음
- 커버링 인덱스 가능
  - 모든 보조 인덱스는 리프 노드에 기본 키를 가지고 있기 때문에 인덱스만으로도 처리될 수 있는 경우가 많음

**단점**
- 모든 보조 인덱스가 기본 키를 가지기 때문에 기본 키 값의 크기가 큰 경우 전체적으로 인덱스의 크기가 커짐
- 보조 인덱스를 통해 검색할 때 기본 키로 한 번 검색을 더 해야됨
- 데이터 삽입 시 기본 키에 의해 레코드를 위치가 결정되므로 처리 성능이 느림
- 데이터 업데이트, 삭제 시 인덱스를 재정렬해야 될 수 있음
- 테이블 당 하나의 클러스터링 인덱스를 가질 수 있는데, 이 인덱스를 잘못 선택하면 쿼리 성능 하락
- 클러스터링 키는 항상 정렬되어 저장되어야 하는데, 기본 키가 비순차적으로 생성되는 경우(UUID 등)에는 데이터 삽입 시 페이지 분할을 유발하여 성능에 영향을 줄 수 있음

## 클러스터링 테이블 주의사항

**키본 키 값에 따른 보조 인덱스 용량 증가**

보조 인덱스는 항상 기본 키 값을 포함함

기본 키 값의 크기가 늘어나면 보조 인덱스의 크기도 자동으로 커지게 됨

보조 인덱스의 개수가 많을수록 그 크기는 배로 늘어남

보조 인덱스가 5개인 경우

| 기본 키 값 크기  |  레코드당 증가하는 인덱스 크기  | 1천만건 레코드 저장 시 증가하는 인덱스 크기  |
|:----------:|:------------------:|:--------------------------:|
|   10 바이트   | 10바이트 * 보조 인덱스 개수  | 50바이트 * 1,000,000 =   47MB |
|   50바이트    | 50바이트 * 보조 인덱스 개수  | 250 * 1,000,000 =   238MB  |

## 유니크 인덱스

유니크 인덱스는 보조 인덱스에 고유성을 더한 인덱스로, 해당 컬럼의 값은 한 개의 레코드에서만 저장될 수 있음

NULL 값을 허용하지 않는 기본 키와는 다르게 유니크 인덱스는 NULL 값을 허용하는데, NULL은 특정 값이 아니므로 2개 이상의 레코드에서 저장될 수 있음

데이터 삽입/수정 시 유니크 인덱스는 제약 검사를 실시해야 되므로 체인지 버퍼를 사용하지 못하므로 보조 인덱스에 비해 성능이 상대적으로 떨어짐

## 외래 키

외래 키란 한 테이블의 특정 컬럼이 다른 테이블의 기본 키 또는 유니크 컬럼과 연결되어 있다는 것을 나타내는 제약조건임

외래 키를 사용하면 두 테이블 간의 참조 무결성을 유지할 수 있음

외래 키 제약조건이 설정된 컬럼에 자동으로 **외래 키 인덱스**가 생성되는데, 외래 키를 삭제하지 않는 한, 이 인덱스를 제거할 수 없음

참고로 외래 키는 InnoDB 스토리지 엔진에서만 생성 가능함

### 외래 키로 인해 락 경합이 발생하는 경우

**자식 테이블의 변경이 대기하는 경우**

1. A 커넥션: 부모 테이블을 수정하는 쓰기 잠금 획득
2. B 커넥션: 자식 테이블의 부모를 변경하는 작업을 수행하려 했으나, 해당 부모 테이블의 쓰기 잠금이 없으므로 대기
3. A 커넥션: 작업 완료(커밋 또는 롤백)
4. B 커넥션: 부모 변경 수행

자식 테이블이 부모 테이블의 외래 키 컬럼을 수정하는 경우 부모 테이블의 확인이 필요한데, 해당 부모 테이블의 쓰기 잠금이 없는 경우 대기해야 됨

외래 키의 컬럼이 아닌 일반 컬럼을 수정하는 경우엔 위의 경우처럼 **잠금 확장**이 발생하지 않음

**부모 테이블의 변경이 대기하는 경우**

1. A 커넥션: 자식 테이블 수정하는 쓰기 잠금 획득
2. B 커넥션: 해당 자식 테이블을 가지고 있는 부모 테이블을 삭제하려 했으나, 자식 테이블의 쓰기 잠금이 없으므로 대기
3. A 커넥션: 작업 완료(커밋 또는 롤백)
4. B 커넥션: 부모 삭제 수행

이처럼 물리적인 외래 키를 생성하면 부모-자식 테이블 간의 참조 무결성을 위해 특정 작업 중에 **읽기 잠금**을 걸어서 부모-자식 관계에 영향을 주는 변경이 발생하지 않도록 함

이를 통해 무결성과 일관성을 유지할 수 있지만

부모나 자식의 해당 레코드에 읽기 잠금을 걸게 되면, 해당 트랜잭션이 작업을 수행하는 동안 다른 트랜잭션에서 잠금으로 인해 대기 상태에 빠짐

이러한 잠금이 다른 테이블로 확장되면 전체적으로 쿼리의 동시 처리에 영향을 미치게 됨

## 인덱스 알고리즘

인덱스를 효율적으로 사용하기 위한 알고리즘으로 각 종류마다 인덱스를 관리하는 데이터 구조와 방식이 상이함

### B-Tree Index (Balanced-Tree Index)

데이터베이스 인덱싱 알고리즘 중 가장 범용적으로 사용되는 알고리즘

데이터가 정렬된 순서로 저장됨

**B-Tree란**

<img src="./images/b-tree-binary-tree.png" alt="b-tree">

[출처](https://open4tech.com/b-tree-vs-binary-tree/)

b-tree의 트리 구조는 **루트 노드(Root Node)**를 시작으로 각 여러 자식 노드를 가질 수 있으며

가장 하위에 있는 노드를 **리프 노드(Leaf Node)**라고 하는데, 루트에서 리프 노트까지의 거리가 동일함

루트 노드도 아니고 리프 노드가 아닌 노드를 **브랜치 노드(Branch Node)**라고 함

**InnoDB의 B-Tree 인덱스**

B-Tree 구조를 사용하면 모든 리프 노드가 동일한 깊이를 가지므로 검색, 쓰기 작업 시 일정한 시간 복잡도를 보장하고, 비싼 디스크 I/O 작업을 줄일 수 있음
- B-Tree 인덱스의 루트 노드는 트리의 시작점으로, 모든 검색 작업의 시작점임
- 브랜치 노드는 인덱스 키 값과 하위 노드의 경로를 가짐
- 리프 노드는 인덱스 키 값(기본 키)을 저장함
  - 데이터 삽입으로 인해 리프 노드가 가득 차면 분할되어 트리 구조를 유지함

데이터 파일(테이블)에는 기본 키를 기준으로 하는 별도의 B-Tree가 구축되어 있고, 인덱스에 저장되어 있는 기본 키를 통해서 다시 한 번 더 검색한 후 기본 키 인덱스에 해당되는 리프 페이지에 저장된 레코드를
읽음

이걸 **클러스터형 인덱스**라고 함

**데이터베이스에 여러 인덱스가 존재할 때**

옵티마이저는 생성된 실행 계획에 따른 비용 계산 결과를 만드는데

여러 인덱스가 존재하면 비용 계산 결과를 바탕으로 가장 적합한 인덱스를 선택하여 인덱스 탐색을 진행함

**검색 및 쓰기 작업에 따른 B-Tree 인덱스 키 추가 및 삭제**

인덱스를 검색하는 작업을 **트리 탐색**이라고 함

트리 탐색은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행함

검색 작업 뿐만 아니라 UPDATE, DELETE를 처리하기 위해 해당 레코드를 먼저 검색할 경우에도 인덱스 트리 탐색이 사용됨

B-Tree 인덱스를 이용한 검색은 100% 완전 일치 또는 값의 앞부분(Left-most part)만 일치하는 경우일 때와 부등호(`>`, `<`) 비교 조건에서 사용할 수 있음

- 검색
  - 기본 키 검색
    - `SELECT * FROM example WHERE id = 100;`
    - 클러스터형 인덱스에서 기본 키 값을 검색하고, 해당 리프 노드에서 데이터를 직접 읽음
  - 유니크 인덱스 검색
    - `SELECT * FROM example name = 'roro';`
    - 유니크 인덱스에서 name 값을 검색하고 리프 노드에서 기본 키를 찾은 다음, 클러스터형 인덱스를 통해 데이터를 읽음
    - 유니크 인덱스는 세컨더리 인덱스와 달리 컬럼에 대한 고유성을 보장함
  - 세컨더리 인덱스 검색
    - `SELECT * FROM example WHERE age = 30;`
    - 세컨더리 인덱스에서 age 값을 검색하고 리프 노드에서 기본 키를 찾은 다음 클러스터형 인덱스를 통해 데이터를 읽음
- 쓰기
  - 기본 키 쓰기(INSERT)
    - `INSERT INTO example (id, name, age) VALUES (1, "roro", 25);`
    - 새로운 기본 키 값을 인덱스에 추가하고, 리프 노드에 새로운 데이터 페이지를 생성하거나 기존 페이지에 데이터를 추가함
    - 인덱스 키 추가 작업은 레코드 추가 작업 비용보다 소모가 큼
    - 필요에 따라 **체인지 버퍼**를 활용해서 작업을 지연시킬 수 있으나, 기본 키의 경우 중복 체크가 필요하므로 버퍼링하지 못하고 즉시 B-Tree에 추가함
  - 유니크 인덱스 쓰기(UPDATE)
    - 유니크 인덱스 컬럼의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
    - 변경된 값이 이미 존재하는 경우, 유니크 제약 조건 위반으로 오류 발생
    - 기본 키와 마찬가지로 중복 체크를 위해 버퍼링 대신 즉시 B-Tree에 추가함
  - 세컨더리 인덱스 쓰기(UPDATE)
    - 세컨더리 인덱스 열의 값이 변경되면, 해당 인덱스 B-Tree에서 기존 엔트리를 삭제하고 새로운 엔트리를 추가함
  - 인덱스 키 삭제
    - 삭제 마킹 처리만 하는데, 이 공간은 그대로 두거나 재활용할 수 있음

**유의사항**

InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키 락은 

검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠금

만약 UPDATE, DELETE 쿼리가 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없는 경우 테이블의 모든 레코드를 잠글 수도 있음

따라서 InnoDB를 사용하는 경우 인덱스 설계가 중요함

**파생**

B-Tree의 변형으로 `B+-Tree`와 `B*-Tree`가 있음

### B+Tree Index

### Hash Index

## B-Tree 성능에 영향을 미치는 요소

- 인덱스를 구성하는 컬럼의 크기
- 레코드 건수
- 유니크 인덱스 키 값의 개수

### 인덱스 키 값의 크기

[페이지(블록)](./inno-db.md#pages)
- 디스크에 데이터를 저장하는 기본 단위
- 모든 읽기 및 쓰기 작업의 최소 단위
- InnoDB 버퍼 풀 버퍼링의 기본 단위

한 개의 인덱스 페이지에 저장할 수 있는 용량
- 인덱스 또한 다른 데이터처럼 페이지로 관리되므로 루트, 브랜치, 리프 노드를 구분하는 기준이 페이지임
- 페이지의 기본 값: 16KB
- 인덱스 엔트리의 키는 16바이트, 값(자식 노드 주소)은 12바이트 정도됨
- 16 * 1024 / (16 + 12) = 약 585개 (한 페이지에 저장할 수 있는 인덱스 엔트리의 개수)

인덱스 키 값의 크기가 늘어날 경우
- 16 * 1024 / (32 + 12) = 약 372개
1. 16 바이트 키 값보다 가져올 수 있는 레코드의 수가 줄어듬 -> 디스크 작업 한 번에 할 걸 두 번 이상 늘어나게 됨
2. 전체적인 인덱스 크기가 커짐 -> 인덱스를 캐시해두는 버퍼 풀의 크기는 제한적이므로 캐시할 수 있는 레코드 수가 줄어듬
3. 한 페이지에 저장할 수 있는 인덱스 엔트리의 수가 줄어듬 -> 동일한 양의 데이터를 저장하기 위한 더 많은 페이지를 필요로 하므로 트리의 높이 증가함

### 선택도 (기수성)

선택도(Selectivity), 기수성(Cardinality)는 인덱스의 유니크한 값의 수를 의미함

전체 레코드 수에 대한 유니크 값의 비율을 나타내는데, 선택도가 높을수록 인덱스는 더 많은 유니크한 값을 포함하고 있음을 의미함

```text
선택도 = 유니크한 값의 수 / 전체 레코드 수
```

테이블에 1천개의 레코드가 있고, 인덱스 컬럼에 900개의 유니크한 값이 있는 경우

(900 / 1000) * 100 = 90의 선택도를 가짐

여기서 유니크한 값은 특정 값이 동일하게 9백개가 있는 게 아니라, 각기 다른 값이 900개가 있다는 말임

선택도에 따른 쿼리 조회 성능 차이
- 기수성이 높은 경우
  - 많은 유니크한 값을 가지고 있는 경우에 해당됨
  - 높은 선택도는 쿼리가 특정 값을 찾을 때 더 적은 수의 레코드를 반환함을 의미함
  - 옵티마이저가 인덱스를 사용하여 레코드를 빠르게 필터링할 수 있게 해줌
  - 사용자 ID와 같은 유니한 값에 대한 기수성은 매우 높은 편
- 기수성이 낮은 경우
  - 유니크한 값이 적은 경우
  - 인덱스가 많은 중복 값을 포함하고 있음을 의미
  - 인덱스를 사용하더라도 많은 레코드를 스캔해야 함 -> 성능 저하
  - 성별, 상태 값의 경우 중복이 많으므로 기수성이 낮은 편

### 레코드 건수

옵티마이저는 쿼리를 실행할 때 인덱스를 사용할 지, 전체 테이블을 직접 스캔할지 결정함

이 결정은 비용 기반으로 이뤄지는데, 옵티마이저가 각각 실행 계획에 대해 예상되는 비용을 계산하고, 가장 낮은 비용의 계획을 선택함

일반적으로 읽어야 하는 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 다음의 이유로 인해 전체 테이블 스캔이 더 효율적이라고 판단할 수 있음
- 랜덤 I/O vs 순차 I/O
  - 인덱스를 사용하면 랜덤 I/O가 발생하게 됨
  - 이는 디스크에서 여러 위치를 찾아야 되므로 많은 비용이 발생됨
  - 반면 순차 I/O의 경우 한 번에 많은 데이터를 읽을 수 있음
  - 상당한 양의 레코드를 읽어야 하는 경우 순차 I/O가 효율적임
- 추가 비용
  - 인덱스를 통해 실제 데이터를 읽기 위해 추가적인 I/O 작업이 필요함
  - 테이블 스캔은 이러한 추가 작업 없이 한 번에 데이터를 읽음

### 최적화 팁

적절한 인덱스 설정
- 고유한 값을 가지는 컬럼에 인덱스를 설정해서 선택도를 높이면 옵티마이저가 빠르게 레코드를 필터링할 수 있음
- 쿼리에 자주 사용되는 컬럼에 인덱스를 설정하여, 옵티마이저가 인덱스를 사용하도록 유도

통계 정보 업데이트
- 테이블의 통계 정보를 주기적으로 업데이트하여 옵티마이저가 최신 정보를 기반으로 최적의 실행 계획을 선택할 수 있도록 함

쿼리 리팩토링
- 옵티마이저가 인덱스를 효율적으로 사용할 수 있도록 쿼리 최적화

## B-Tree 인덱스 스캔

쿼리를 실행할 때 인덱스를 사용하여 데이터를 검색하는 방법을 **인덱스 스캔**이라고 함

### 레인지 스캔 (Range Scan)

인덱스 접근 방법 중 가장 대표적인 접근 방식으로 인덱스의 특정 범위를 스캔해서 필요한 데이터를 조회함

레인지 스캔 단계
1. 인덱스에서 조건을 만족하는 값을 찾음 - 인덱스 탐색(index seek)
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 순서대로 읽어들임 - 인덱스 스캔
3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 읽은 후, 실제 레코드를 가져옴

실제 레코드를 가져올 때 레코드마다 랜덤 I/O가 발생하기 때문에 비용이 많이 드는 작업에 속함

레인지 스캔이 사용되는 상황
- WHERE 절에 범위 조건(BETWEEN, <, >, <=, >=)이 사용된 경우
- 인덱스의 선두 부분(Prefix)을 기준으로 범위 조건이 사용된 경우

불필요한 전체 테이블 스캔을 피하고, 필요한 범위만 스캔을 하므로 I/O 비용이 줄어듬

```mysql
SELECT * FROM employees WHERE employee_id BETWEEN 50000 AND 100000;
```

employee_id 컬럼에 인덱스가 설정되어 있다면 id 인덱스를 이용해서 범위 조건에 맞는 로우를 스캔함

### 커버링 스캔 (Index-Only Scan)

레인지 스캔 단계 중 세 번째 단계를 뺀 접근 방식

쿼리에서 필요한 모든 데이터가 인덱스 자체에 포함된 경우 디스크 I/O를 통해 실제 데이터 페이지를 읽지 않음

커버링 스캔이 사용되는 상황
- 인덱스만으로도 필요한 모든 데이터를 가져올 수 있는 상황
  - SELECT 절에 포함된 모든 열이 인덱스에 포함된 경우
  - WHERE 절이나 ORDER BY 절에 사용된 열이 인덱스에 포함된 경우

실제 데이터 페이지를 읽을 필요가 없으므로 낮은 I/O 비용을 가지며, 더 빠른 쿼리 성능을 제공함

```mysql
# 인덱스 생성
CREATE INDEX idx_emp_dept_name ON employees(department_id, first_name, last_name);

# 인덱스에 포함된 데이터만 조회
SELECT first_name, last_name
FROM employees
WHERE deparment_id = 10;
```

인덱스 `idx_emp_dept_name`은 deparment_id, first_name, last_name 컬럼을 모두 포함하고 있으므로, 커버링 인덱스 스캔이 사용됨

```mysql
SELECT first_name, last_name FROM employees WHERE department_id = 10;
```

### 풀 스캔 (Full Index Scan)

인덱스의 처음부터 끝까지 순차적으로 모든 인덱스 엔트리를 읽는 방식

풀 스캔이 사용되는 상황
- 테이블의 모든 로우를 읽어야 되는 상황
- 인덱스에 대한 범위 조건이 없는 경우
- 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우

인덱스의 크기는 테이블의 크기보다 작은 게 일반적이므로, 직접 테이블을 처음부터 끝까지 읽는 거(테이블 풀스캔)에 비해 효율적임

쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 커버링 인덱스 스캔이 될 수 있음

인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 이 방식으로 처리되지 않음

```mysql
# 아래의 인덱스가 있다고 가정
CREATE INDEX idx_emp_dept_name ON employees(department_id, first_name, last_name);

# 테이블의 모든 로우를 조회 - 테이블 풀 스캔
SELECt * FROM employees;

# 인덱스에 대한 범위 조건 없이 조회 - 인덱스 풀 스캔 (커버링)
SELECT first_name, last_name FROM employees;

# 인덱스의 첫 번째 컬럼(deparment_id)을 조건절에 사용하지 않은 경우 - 인덱스 풀 스캔 (커버링)
SELECT last_name FROM employees WHERE first_name = 'John';
```

### 유니크 인덱스 조회 (Unique Index Lookup)

### 루스 인덱스 스캔 (Loose Index Scan)

특정 조건을 만족하는 인덱스 엔트리만 선택적으로 스캔하는 방식

옵티마이저가 그룹화나 중복 제거를 위해 인덱스의 전체 범위를 스캔하지 않고, 조건을 만족하는 최소한의 인덱스 엔트리만 스캔함

즉, 불필요한 인덱스 엔트리는 건너뛰고 조건에 맞는 인덱스 엔트리만 읽어서 성능을 최적화함

루스 인덱스 스캔이 사용되는 상황
- `GROUP BY`, `DISTINCT` 쿼리 
- 집합 함수 `MAX()`, `MIN()` 최적화

조건에 만족하는 인덱스를 읽으면 `WHERE` 조건을 만족하는 범위 전체를 다 스캔하지 않고 생략한 뒤, 다음 레코드로 이동함

루스 인덱스 스캔을 사용하려면 여러 가지 조건을 만족해야 됨

## 인덱스 스킵 스캔 (Index Skip Scan)

복합 인덱스를 사용할 때 인덱스의 선두 컬럼(primary column)이 쿼리 조건에 없더라도, 그 다음 컬럼으로 인덱스를 탐색하는 방식

인덱스 중간 열들만 사용해도 효율적으로 검색할 수 있게 해줌

동작 방식
- 선두 컬럼의 고유 값 순차 탐색
- 선두 컬럼이 쿼리 조건에 없는 경우, 선두 컬럼의 각 고유 값에 대해 다음 인덱스 컬럼을 사용하여 조건에 맞는 엔트리를 탐색

```mysql
# 예시 인덱스
CREATE INDEX idx_age_name ON employees(age, last_name);

# 인덱스의 선두 컬럼없이 조회
SELECT * FROM employees WHERE last_name = 'Anna';
```

위의 `SELECT` 쿼리를 실행하면 옵티마이저는 먼저 선두 컬럼인 age 컬럼의 유니크 값을 모두 조회함

그 다음 각 age 값에 대해 `last_name = 'Anna'` 조건을 만족하는 레코드를 탐색함

인덱스의 유연한 설계를 제공하지만, 선두 컬럼의 고유 값이 많은 경우 각 고유 값마다 후속 열을 탐색해야 하기 때문에 탐색 비용이 증가할 수 있음

-> 선두 컬럼이 가진 유니크 값의 개수가 소량일 때 적용 가능한 최적화라고 생각하면 됨(성별, 상태 값)

## B-Tree 인덱스 정렬 및 스캔 방향

- 인덱스의 키 값은 기본적으로 오름차순으로 항상 정렬됨(내림차순으로 설정 가능)

```text
       오름차순 인덱스                 내림차순 인덱스
       
           [a]                         [a]
            |                           |
    [b] <---|---> [c]           [b] <---|---> [c]
```

오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스

내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스

**스캔 방향**이란 리프 노드에서의 탐색 방향을 의미함

- 옵티마이저가 만들어내는 실행 계획에 따라 정해진 스캔 방향을 통해, 정렬된 방향과 무관하게 어느 쪽으로든지 인덱스를 읽을 수 있음
  - 보통 `ORDER BY` 절에 따라 스캔 방향이 결정됨

(실제로 정렬은 내림차순이지만, 끝에서부터 읽으면 오름차순이 됨)

**순방향(Forward) 스캔**
- 인덱스가 정의된 방향대로 스캔하는 방식
- 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
- 인덱스가 오름차순으로 정의된 경우: 오름차순 스캔
- 인덱스가 내림차순으로 정의된 경우: 내림차순 스캔

**역방향(Backward) 스캔**
- 인덱스가 정의된 반대 방향으로 스캔하는 방식
- 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
- 인덱스가 오름차순으로 정의된 경우: 내림차순 스캔
- 인덱스가 내림차순으로 정의된 경우: 오름차순 스캔

### 정렬 방향 설정과 쿼리에 따른 스캔 방향 선택

인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 설정할 수 있음

```mysql
CREATE INDEX ix_fisrt_name_asc ON employees (first_name ASC);
```

`ORDER BY` 절에 따라 스캔 방향을 정할 수 있음

```mysql
SELECT *
FROM employees
ORDER BY first_name >= "Anna" ASC
LIMIT 5;
```

순방향으로 first_name 인덱스를 읽으면서 조건에 포함되는 5개의 레코드 조회

```mysql
SELECT *
FROM employess
ORDER BY fist_name DESC;
```

first_name 인덱스를 역방향으로 읽으면서 5개의 레코드 조회

fisrt_name은 오름차순으로 설정됐지만 역방향 스캔을 수행해서 내림차순으로 데이터 정렬

### 인덱스 정렬 순서와 ORDER BY에 따른 스캔 방향

순방향: 인덱스 정렬 순서와 ORDER BY 절이 일치하는 경우에 결정됨

역방향: 인덱스 정렬 순서와 ORDER BY 절이 불일치하는 경우에 결정됨

**단일 컬럼 인덱스**

|  인덱스 정렬 순서  |  ORDER BY 정렬 순서  | 스캔 방향  |
|:-----------:|:----------------:|:------:|
|     ASC     |       ASC        |  순방향   |
| ASC | DESC| | 역방향|
|DESC | ASC | 역방향 |
| DESC | DESC | 정방향|

**다중 컬럼 인덱스**

각 컬럼의 정렬 순서와 ORDER BY 절에 지정된 순서에 따라 스캔 방향 결정

인덱스의 첫 번째 컬럼부터 시작해 ORDER BY 절과 매칭 시도, 그 후 다음 컬들의 일치 여부 확인

아래의 표는 2개의 컬럼을 인덱스로 갖는 경우 매칭되는 경우의 수임

다중 컬럼이 더 추가되거나 `WHERE`절이 추가되면 더 복잡해질 수 있음

| 컬럼 인덱스 1 | 컬럼 인덱스 2 | ORDER BY 컬럼 1 | ORDER BY 컬럼 2 | 스캔 방향  |
|:--------:|:--------:|:-------------:|:-------------:|:------:|
|   ASC    |   ASC    |      ASC      |      ASC      |  순방향   |
|   ASC    |   ASC    |     DESC      |     DESC      |  역방향   |
|   DESC   |   DESC   |      ASC      |      ASC      |  역방향   |
|   DESC   |   DESC   |     DESC      |     DESC      |  순방향   |
|   ASC    |   DESC   |      ASC      |     DESC      |  순방향   |
|   ASC    |   DESC   |     DESC      |      ASC      |  역방향   |
|   DESC   |   ASC    |     ASC       |     DESC      |  역방향   |
|   DESC   |   ASC    |     DESC      |      ASC      |  순방향   |

**ORDER BY 절이 없는 경우**

`ORDER BY` 절이 없으면 `WHERE`절의 조건이 인덱스의 첫 번째 컬럼이나 여러 컬럼에 걸쳐 있을 때, 인덱스에 정의된 순서대로 순방향으로 스캔함

### 스캔 방향과 쿼리 성능의 관계

옵티마이저는 인덱스의 정렬 순서와 `ORDER BY`절을 바탕으로 스캔 방향을 결정하는데, 

쿼리가 인덱스를 스캔하는 방향과 인덱스의 정렬 순서가 잘 맞아떨어져야 데이터 조회 성능을 높일 수 있음

즉, 쿼리의 `WHERE` 조건과 `ORDER BY` 절이 인덱스 정렬 순서와 일치할 때, 인덱스를 효과적으로 사용할 수 있음

**순방향 스캔과 역방향 스캔의 성능 차이** 

역방향 스캔 방식의 성능은 순방향에 비해 약간 떨어짐

원인
- 페이지 잠금이 인덱스 순방향 스캔에 적합한 구조임
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조임

## 쿼리별 인덱스 사용 방법

**예시 데이터**

```mysql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    hire_date DATE,
    salary DECIMAL(10, 2)
);

CREATE INDEX idx_hire_date_salary ON employees (hire_date ASC, salary DESC);

CREATE INDEX idx_first_name ON employees (first_name);

INSERT INTO employees (employee_id, first_name, last_name, hire_date, salary) VALUES
(1, 'Alice', 'Smith', '2024-06-01', 60000.00),
(2, 'Bob', 'Brown', '2024-06-01', 70000.00),
(3, 'Charlie', 'Davis', '2024-07-01', 50000.00),
(4, 'David', 'Evans', '2024-08-12', 80000.00),
(5, 'Eve', 'Foster', '2024-08-12', 75000.00);
```

**공통 제약사항**
- MySQL B-Tree 인덱스는 왼쪽 기준(Left-most) 정렬 기반이므로 항상 인덱스를 사용할 때 앞의 컬럼 인덱스를 포함해야 됨
- 즉, 다중 컬럼 인덱스의 중간 컬럼 인덱스만 사용한 경우 인덱스를 아예 사용하지 못함
- 그리고 각 컬럼은 인덱스를 적용할 수 있도록 적절하게 사용되어야 함


### WHERE 절

`WHERE` 절은 데이터 필터링을 수행하는 데 사용됨

B-Tree 인덱스는 특정 컬럼이나 컬럼 조합에 대한 검색을 빠르게 수행할 수 있도록 도와줌

**단일 컬럼 인덱스의 경우**
- `WHERE` 절이 인덱스가 적용된 컬럼을 직접 참조하면 인덱스가 사용됨

**다중 컬럼 인덱스의 경우**
- 단일 컬럼 인덱스와 마찬가지로 `WHERE` 절이 인덱스가 적용된 컬럼을 직접 참조하면 인덱스가 사용되는데,
- `WHERE` 절이 인덱스의 첫 번째 컬럼에 대한 조건을 포함하고, 그 다음 조건이 그 다음 컬럼을 포함할 때 인덱스가 사용됨
- 다만 **WHERE 절의 첫 번째 조건이 인덱스의 첫 번째 컬럼과 일치하지 않는다면 인덱스를 사용할 수 없음**

**인덱스 사용 방식**
- 조건 절에 사용된 조건의 종류에 따른 인덱스 스캔을 결정함
- 동등 비교 조건 (`=`)
  - 해당 인덱스 키에 대해 정확한 값을 찾기 위한 인덱스 탐색
- 범위 조건 (`>`, `>=`, `<`, `<=`,`BETWEEN`)
  - 레인지 스캔(인덱스의 특정 범위)이 이뤄짐

```mysql

/* 
  hire_date에 대한 동등 비교 조건
  hire_date는 인덱스의 첫 번째 컬럼이므로 인덱스 사용 가능
  동등 조건을 사용하여 인덱스를 검색하고, 해당하는 행을 반환함
/*
SELECT * FROM employees WHERE hire_date = '2024-08-12';

/*
  salary에 대한 범위 조건
  salary 컬럼은 인덱스의 두 번째 컬럼이므로, 인덱스를 사용할 수 없음
  따라서 테이블 풀 스캔을 통해 조건에 맞는 행을 찾아야 됨
*/
SELECT * FROM employees WHERE salary > 60000;

/* 
  hire_date, salary에 대한 결합 조건 (동등 비교 후, 범위 조건)
  hire_date에 대해 동등 조건을 사용한 후, 해당 범위 내에서 `salary DESC` 조건에 따라 레인지 스캔 수행
  레인지 스캔 수행 후 동등 조건을 수행하기 보다, 동등 조건을 통해 레인지 스캔 수행 범위를 좁히는 방식이 더 나음
/*
SELECT * FROM employees WHERE hire_date = '2024-08-12' AND salary = > 50000;

/*
  hire_date, salary에 대한 결합 조건 (둘 다 범위 조건)
  hire_date에 대해 레인지 스캔을 수행하고, 해당 범위 내에서 salary에 대해 레인지 스캔 수행
*/
SELECT * FROM employees WHERE hire_date >= '2024-07-01' AND salary <= 70000

/*
  first_name에 대한 동등 비교 조건
  first_name에 대한 인덱스가 존재하지만, 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾을 수 없음
  따라서 테이플 풀 스캔 후 일치하는 값을 조회함
*/
SELECT * FROM employees WHERE first_name LIKE '%th';
```

### ORDER BY 절

`ORDER BY`절은 쿼리 결과를 특정 기준에 따라 정렬하는 데 사용됨

인덱스는 항상 정렬되므로 `ORDER BY`와 적절히 매칭되면 인덱스를 효과적으로 사용할 수 있음

[인덱스 정렬 순서와 ORDER BY에 따른 스캔 방향](#인덱스 정렬 순서와 ORDER BY에 따른 스캔 방향)


**단일 컬럼 인덱스의 경우**
- `ORDER BY` 절이 인덱스가 적용된 컬럼을 참조하면, 인덱스가 사용되어 추가적인 정렬 작업을 피할 수 있음


**다중 컬럼 인덱스의 경우**
- `ORDER BY` 절이 다중 컬럼 인덱스의 앞부분부터 순서대로 컬럼을 포함할 때 인덱스가 사용됨

**인덱스 사용 방식**
- 순방향 스캔: `ORDER BY`절의 정렬 순서와 인덱스의 정렬 순서가 일치하는 경우
- 역방향 스캔: `ORDER BY`절의 정렬 순서가 인덱스의 정렬 순서와 반대인 경우

```mysql
# hire_date와 salary 인덱스의 정렬 순서와 맞는 경우 순방향 스캔
SELECT * FROM employees ORDER BY hire_date ASC, salary DESC;

# salary 인덱스의 정렬 순서가 맞지 않은 경우(역방향 스캔 또는 추가적인 정렬 작업 수행)
SELECT * FROM employees ORDER BY hire_date ASC, salary ASC;
```

### GROUP BY 절

`GROUP BY` 절은 데이터를 특정 컬럼 기준으로 그룹화하는 데 사용됨

인덱스를 활용하면 그룹화 작업을 더 빠르게 수행 가능

**단일 컬럼 인덱스의 경우**
- `GROUP BY`절이 인덱스가 적용된 단일 컬럼을 참조할 때 인덱스가 사용될 수 있음

**다중 컬럼 인덱스의 경우**
- `GROUP BY`절이 다중 컬럼 인덱스의 앞부분부터 순서대로 컬럼을 포함할 때 인덱스가 사용됨

**인덱스 사용 방식**
- 정렬된 인덱스 스캔: `GROUP BY`절이 인덱스의 정렬 순서와 일치하면 인덱스를 사용해 이미 정렬된 상태에서 그룹화 수행
- 그룹화와 정렬 최적화: `GROUP BY`와 `ORDER BY`절이 동일한 인덱스 컬럼에 대해 사용되는 경우, 한 번의 인덱스 스캔으로 그룹화와 정렬을 모두 수행 가능

```mysql

/*
  hire_date에 대한 그룹화 수행 (정렬된 인덱스 스캔)
  hire_date는 인덱스의 첫 번째 컬럼이므로 인덱스 사용 가능
*/
SELECT hire_date, COUNT(*) FROM employees GROUP BY hire_date;

/*
  hire_date와 salary를 기준으로 그룹화 수행 (정렬된 인덱스 스캔)
  인덱스(hire_date ASC, salary DESC)가 정의되어 있으므로, 두 컬럼에 대해 인덱스 사용 가능
*/
SELECT hire_date, salary, COUNT(*) FROM employees GROUP BY hire_date, salary;

/*
  salary를 기준으로 그룹화 수행
  salary는 인덱스의 두 번째 컬럼이므로 인덱스를 사용해서 그룹화를 수행할 수 없음
  테이블 풀 스캔을 통해 salary를 기준으로 그룹화 수행
*/
SELECT salary, COUNT(*) FROM employees GROUP BY salary;

/*
  hire_date, first_name에 대한 그룹화 수행
  인덱스는 last_name 포함하지 않으므로 인덱스를 사용할 수 없음
  테이블 풀 스캔을 통해 hire_date와 last_name 기준으로 그룹화 수행
*/
SELECT hire_date, last_name, COUNT(*) FROM employees GROUP BY hire_date, last_name;
```

### 결합 조건

`WHERE`, `GROUP BY`, `ORDER BY` 절이 함께 사용된 경우엔 옵티마이저가 가장 효율적인 방법을 선택함

**모든 조건이 인덱스에 적용된 컬럼을 참조하는 경우**
- 효율적으로 인덱스 사용 가능

**여러 조건이 결합된 경우**
- 쿼리의 조건들이 인덱스의 앞부분 컬럼부터 일치해야 됨

**인덱스 사용 방식**
- 복합 스캔: 여러 조건에 맞는 복합 인덱스를 사용할 경우, 인덱스를 스캔하면서 필터링, 정렬, 그룹화를 한 번에 수행 가능

```mysql

/*
  WHERE + GROUP BY + ORDER BY

  where 절의 salary 조건은 인덱스의 두 번째 컬럼에 적용되므로 첫 번째 컬럼 인덱스없이 인덱스를 사용할 수 없음
  테이블 풀 스캔을 통해 where 절의 조건을 만족하는 행을 필터링한 뒤
  hire_date를 기준으로 그룹화하고, hire DESC로 정렬
*/
SELECT hire_date, COUNT(*)
FROM employees
WHERE salary > 65000
GROUP BY hire_date
ORDER BY hire_date DESC;

/*
  where 절의 hire_date 조건은 인덱스의 첫 번째 컬럼에 적용되므로 인덱스 사용 가능
  GROUP BY절의 hire_date, salary 순서는 인덱스의 순서와 일치함
  where 절의 hire_date에 대한 레인지 스캔 수행 후, 그 결과에 대해 `salary DESC` 인덱스 순서대로 '정렬된 인덱스 스캔'을 수행하며 그룹화 처리 진행
*/
SELECT hire, salary, COUNT(*)
FROM employees
WHERE hire_date >= '2024-07-01'
GROUP BY hire_date, salary;

/*
  where 절의 hire_date 조건은 인덱스의 첫 번째 컬럼에 적용되므로 인덱스 사용 가능
  ORDER BY 절의 `hire_date ASC, salary DESC`는 인덱스 순서와 정확히 일치함
  where 절의 hire_date에 대한 레인지 스캔 수행 후 순방향 스캔(추가적인 정렬 작업 X)으로 데이터를 가져옴
*/
SELECT *
FROM employees
WHERE hire_date > '2024-07-01'
ORDER BY hire_date ASC, salary DESC;
```