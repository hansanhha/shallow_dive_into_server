[도커 이미지](#도커-이미지)

[이미지 빌드](#이미지-빌드)

[이미지 레이어](#이미지-레이어)

[환경 변수](#환경-변수)

[이미지 이름](#이미지-이름)

[레지스트리](#레지스트리)

[도커 파일 명령어](#도커-파일-명령어)

[컨테이너 이미지 빌드 명령어](#컨테이너-이미지-빌드-명령어)

[멀티 스테이지 빌드](#멀티-스테이지-빌드)


## 도커 이미지

이미지는 애플리케이션과 모든 의존성(라이브러리, 소스 코드, 설정 파일, 환경 변수)을 패키징하며 실행 환경을 정의한다

도커의 이미지는 OCI(Open Container Initiative) 표준을 따라서 다양한 OS 플랫폼에서 실행할 수 있다


## 이미지 빌드

컴파일러와 같은 빌드 도구를 사용하여 프로그램을 빌드해서 실행 파일을 만드는 것처럼 도커는 도커 파일을 기반으로 이미지를 빌드한 뒤, 빌드된 이미지를 통해 컨테이너를 실행한다

빌드 과정은 도커 엔진이 도커 파일의 명령어를 하나씩 실행하고 각 명령어로 인해 새로운 레이어를 생성하여 최종적으로 이미지를 완성하는 방식으로 진행된다

#### 도커파일 읽기

`docker build` 명령을 실행하면 도커는 지정된 디렉토리에서 `Dockerfile`을 찾는다

도커 파일은 이미지 빌드 과정에서 실행될 명령어를 정의한 스크립트 파일이다

#### 베이스 이미지 설정

도커 파일의 첫 번째 명령인 `FROM`을 읽고 해당 베이스 이미지를 기반으로 작업을 시작한다

`FROM ubuntu:20.04`는 우분투 20.04 이미지를 기반으로 설정한다

지정된 이미지가 로컬에 없으면 도커는 도커 레지스트리(docker hub 등)에서 이미지를 다운로드한다

#### 명령어 실행 및 레이어 생성

도커 파일의 각 명령(`RUN` `COPY` `ADD`)을 순차적으로 실행한다

각 명령은 새로운 읽기 전용 레이어를 생성하며 이전 레이어 위에 추가된다

```dockerfile
RUN apt-get update
RUN apt-get install -y vim
```

위 두 명령은 각각 새로운 레이어를 생성한다

레이어를 생성할 때, 도커는 캐시를 활용하여 이전에 동일한 명령으로 생성된 레이어가 있는 경우 이를 재사용한다

#### 파일 시스템 변경 반영

명령어가 실행될 때 파일 추가/수정/삭제와 같은 변경 사항이 현재 레이어에 기록된다

레이어는 불변이므로 변경 사항은 새로 생성된 레이어에만 반영되고 기존 레이어에는 영향을 미치지 않는다

#### 레이어 최적화 및 캐싱

도커는 레이어를 캐시하여 빌드 성능을 최적화한다

동일한 도커 파일로 이미지를 다시 빌드할 때 이전 빌드에서 생성된 레이어를 재사용하여 빌드 시간을 줄인다

e.g `COPY` 명령으로 파일을 복사할 경우 파일이 변경되지 않았다면 해당 레이어를 재사용한다

#### 최종 이미지 생성

모든 명령어가 실행되면 도커는 여러 레이어를 하나로 합쳐 최종 이미지를 생성한다

이미지는 읽기 전용 레이어의 집합으로 구성되며, 컨테이너 실행 시 이 레이어가 그대로 사용된다


## 이미지 빌드 예시

### 도커 파일 작성

```dockerfile
FROM ubuntu:20.04
RUN apt-get update
RUN apt-get install -y vim
COPY . /app
CMD ["vim"]
```

#### `FROM unbuntu:20.04`

우분투 20.04 이미지를 기반으로 설정한다

베이스 이미지 레이어가 추가된다

#### `RUN apt-get update`

패키지 목록을 업데이트하는 명령을 실행한다

새로운 레이어가 생성된다

#### `RUN apt-get install -y vim`

vim 패키지를 설치한다

새로운 레이어가 추가된다

#### `COPY . /app`

현재 디렉토리의 파일을 컨테이너의 /app 경로로 복사한다

파일 복사로 인해 새로운 레이어가 생성된다

#### `CMD["vim"]`

컨테이너가 실행될 때 기본적으로 실행할 명령을 설정한다

### 빌드 명령 실행

```shell
docker build -t example-image .
```

`-t example-image`: 이미지를 example-image라는 이름으로 태그한다

`.`: 도커 파일이 위치한 현재 디렉토리를 빌드 컨텍스트로 사용한다

### 빌드 후 결과물

example-image라는 이름의 도커 이미지가 생성된다

`docker images` 명령으로 생성된 이미지를 확인할 수 있다


## 이미지 레이어

하나의 이미지는 한 개 이상의 레이어로 구성되어 있으며, 이를 기반으로 컨테이너를 생성하고 실행한다

레지스트리에서 이미지를 다운받을 때 하나의 파일이 아닌 여러 파일을 받는데, 이들 각각의 파일이 이미지를 구성하는 레이어다

도커는 이 파일들을 조립해서 컨테이너 내부 파일 시스템을 만든다

도커 파일 명령어와 이미지 레이어는 1:1 관계를 가진다

#### 이미지 레이어 구조

도커 이미지는 물리적으로 작은 여러 개의 파일(레이어)로 구성되어 있다

==

레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일로, 이미지의 각 레이어는 아래 레이어의 스냅샷이며, 상위 레이어는 하위 레이어를 확장함

이 구조는 이미지 간에 레이어를 재사용할 수 있게 하고, 저장 공간을 절약하며 이미지 빌드 시간을 단축하게 함

서로 다른 이미지(애플리케이션)여도 동일한 이미지 레이어를 사용하면 도커 엔진에 캐시된 이미지 레이어를 공유함 -> 그만큼 디스크 공간이 절약됨

#### 이미지 빌드 최적화

도커 파일 스크립트의 명령어가 각각 하나의 이미지 레이어와 1대1 연결되므로, 명령어의 결과가 이전 빌드와 같다면 이전에 캐시된 레이어를 재사용함

도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용함 

해시값은 도커 파일 스크립트의 명령어와 명령어에 의해 복사되는 파일의 내용으로부터 계산되는데, 기존 이미지 레이어에 해시값이 일치하는 것이 없다면 캐시 미스가 발생하여 레이어를 재사용하는 대신 해당 명령어가 실행됨

한 번 명령어가 실행되면 그 뒤에 오는 명령어는 수정되는 것이 없더라도 모두 실행됨

**따라서 잘 수정되지 않는 명령어는 앞으로 오고, 자주 수정되는 명령어는 뒤에 오도록 배치돼야 함**



## 환경 변수

환경 변수는 운영체제에서 제공하는 키-값 쌍임

윈도우나 리눅스에서 환경 변수를 사용할 수 있듯이, 도커 컨테이너도 자체적인 별도의 환경 변수를 가짐

도커 이미지는 설정값의 기본값을 포함해 패키징되지만 컨테이너를 실행할 때 이 설정값을 바꿀 수 있어야 함

도커 컨테이너의 환경변수를 이용하면 간단하게 설정값을 바꿔 애플리케이션의 동작을 의도한대로 변경할 수 있음

동일한 이미지를 가지고도 설정값에 의해 동작을 다르게 할 수도 있음

즉, 애플리케이션의 설정값을 컨테이너에서 받도록하여 다른 환경에도 애플리케이션을 배포할 수 있도록 이식성 있는 이미지를 만들 수 있어야 함

## 이미지 이름

도커 이미지의 전체 이름을 이미지 참조(reference)라고 함

이미지 참조 구조

```text
domain/group/repository:tag
```

- domain: 이미지 레지스트리 도메인, 기본값은 도커 허브임
- group: 이미지 작성자(개인 혹은 단체 이름)
- repository: 이미지 리포지토리 이름, 일반적으로 애플리케이션의 이름에 해당함
- tag: 애플리케이션 버전을 나타냄, 기본값은 latest임

레지스트리와 태그 정보를 따로 지정하지 않는 경우 기본 값을 사용함

이미지는 여러 개의 참조를 가질 수 있음

태그엔 어떤 문자열이든 명시할 수 있지만, 일반적으로 major.minor.patch 시맨틱 버저닝 형식을 따름

이미지를 다운받을 때 patch 버전(1.10.5)까지 콕 집어 명시하면 항상 같은 버전을 보장받음 - 이후에 명시적으로 변경하지 않는 한 보안 패치를 받을 수 없음

그리고 상위 버전만 명시한 경우(1.5 또는 1)엔 해당 하위 버전은 업데이트된 최신 버전을 전달받음 - 지속적인 업데이트를 받을 수 있지만, 기능 변경으로 인한 예기치 않은 상황이 발생할 수 있음

## 레지스트리

레지스트리는 도커 이미지를 업로드하고 다운로드할 수 있는 공간으로

Docker Hub와 같은 공개 레지스트리와 기업이나 팀에서 내부적으로 사용하기 위한 프라이빗 레지스트리로 나뉨

도커 레지스트리도 로컬 컴퓨터에서 동작하는 도커 엔진과 같은 방식으로 이미지 레이어를 다룸

즉, 이미지를 레지스트리에 푸시할 때 실제로 업로드 대상이 되는 것은 이미지 레이어임

레지스트리의 캐시상에 레이어 해시와 일치하는 레이어가 없을 경우에만 실제로 업로드가 이뤄짐

레이어가 기존 캐시를 재사용할 수 있도록 이미지를 최적화했다면, 그만큼 네트워크 대역폭의 낭비를 줄일 수 있음

## 도커 파일 명령어

#### FROM

베이스 이미지를 지정함

`FROM ubuntu:20.04`

#### RUN

이미지 빌드 시 실행할 명령어를 지정함

`RUN apt-get update && apt-get install -y git`

#### ENV

환경 변수 값을 설정함

값을 지정하기 위해 [key]=[value] 형식을 따름

```Dockerfile
ENV USER=ubuntu-user
ENV HOME=/home/$USER
```

#### WORKDIR

컨테이너 이미지 파일 시스템에 디렉토리를 만들고, 해당 디렉토리를 작업 디렉토리로 지정하는 명령어임

리눅스와 윈도우 컨테이너 모두 구분자로 슬래시(/)를 사용함

#### COPY

로컬 파일 시스템(호스트)의 파일 또는 디렉토리를 컨테이너 이미지로 복사함

[원본 경로] [복사 경로] 형식으로 지정하면 됨

`COPY . /app

#### CMD

컨테이너 실행 시 기본적으로 실행할 명령어를 지정함

`CMD ["python", "app.py"]

## 컨테이너 이미지 빌드 명령어

이미지를 빌드하려면 다음과 같은 것들이 필요함
- 도커 파일
- 이미지 이름, 이미지 태그
- 패키징에 필요한 파일의 경로

`docker image build -t <image_name>:<tag> <file_path>`

tag를 별도로 명시하지 않는 경우 `latest` 태그가 자동적으로 붙음

도커 파일 및 이미지에 포함시킬 파일이 위치한 경로를 도커에서는 컨텍스트라고 함

```
// 현재 파일 경로에 도커 이미지를 빌드하는 경우의 명령어

docker image build -t simple-image:0.0.1 .

```

## 멀티 스테이지 빌드

도커 이미지 빌드의 효율성을 올리기 위한 기법으로, 

하나의 도커 파일에서 여러 개의 빌드 단계를 정의하여 최종적으로 필요한 부분만을 포함하는 경량화된 이미지를 생성할 수 있음

멀티 스테이지 빌드는 도커 파일에서 여러 개의 `FROM` 명령어를 사용해 각 단계마다 다른 베이스 이미지를 정의할 수 있음

각 단계는 독립적인 환경에서 동작하며, 이전 단계의 아티팩트를 가져와서 사용할 수 있음

#### 장점

경량 이미지 생성
- 불필요한 빌드 도구나 라이브러리를 최종 이미지에 포함하지 않음
- 결과적으로 이미지 크기가 작아짐

성능 향상
- 멀티 스테이지 빌드의 각 단계는 별도의 캐시를 가짐
- 도커는 빌드 중에 각 명령어에 해당하는 레이어 캐시를 찾는데, 찾지 못한다면 남은 명령어가 모두 실행되지만 그 범위가 해당 단계만으로 국한됨
- 이어지는 다음 단계는 다시 캐시를 재사용할 수 있음
- 도커 파일 스크립트를 최적화해서 작성할수록 캐시 재사용을 통해 빌드 단계 시간을 절약할 수 있음

빌드 과정 단순화
- 여러 단계의 빌드를 하나의 도커 파일에서 관리할 수 있어, 복잡한 빌드 파이프라인을 단순화할 수 있음
- 각 단계는 독립적이기 때문에 특정 단계만 수정하고 다시 빌드할 수 있음

보안 강화
- 최종 이미지에는 실행에 필요한 파일만 포함됨
- 잠재적으로 보안 취약점이 될 수 있는 빌드 도구나 라이브러리가 포함되지 않음
- 소스 코드가 포함되지 않기 때문에 코드 유출의 위험도 줄어듦

```dockerfile
# 1단계: 빌드 단계
FROM golang:1.18 AS builder

# 작업 디렉토리 설정
WORKDIR /app

# 모듈 다운로드 및 캐시
COPY go.mod ./
COPY go.sum ./
RUN go mod download

# 소스 코드 복사 및 빌드
COPY . ./
RUN go build -o simple-app .

# 2단계: 실행 단계
FROM alpine:latest

# 최종 실행 파일만 복사
COPY --from=builder /app/simple-app /usr/loca/bin/simple-app

# 기본 실행 명령어 설정
CMD ["simple-app"]
```

## 이미지 종류

검증된 퍼블리셔
- 이미지를 배포하는 단체 중 오라클, IBM같은 신회할 수 있는 큰 기업

공식 이미지
- 주로 오픈소스 소프트웨어 이미지
- 해당 프로젝트 개발 팀과 도커가 함께 이미지를 관리함

일반 이미지
- 도커 이미지 중에서 기본적인 기능을 갖춘 이미지
- 보통 특정 언어의 런타임, 라이브러리, 운영 체제 등 일반적인 환경을 포함함
- 다양한 환경에 맞게 커스터마이징

골든 이미지
- 특정 조직이나 프로젝트의 필수 구성 요소와 설정이 모두 포함된 표준화 이미지
- 모든 컨테이너가 동일한 환경에서 시작되도록 보장함
- 특정 버전의 애플리케이션, 라이브러리, 설정 파일 등이 포함되어 있으며, 이 이미지를 기반으로 하는 모든 컨테이너가 동일한 환경에서 실행되도록 보장함
- 일반 이미지를 사용하여 커스터마이징을 할 수 있지만, 골든 이미지를 사용하면 모든 배포 환경에서 동일한 조건을 유지할 수 있음
